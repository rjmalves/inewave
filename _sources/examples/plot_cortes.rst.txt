
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/plot_cortes.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_plot_cortes.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_plot_cortes.py:


=======================================================
Análise dos cortes de Benders e política operativa
=======================================================

.. GENERATED FROM PYTHON SOURCE LINES 9-13

O arquivo cortes.dat (binário) contém os cortes de Benders gerados durante
o processo de otimização do NEWAVE. Estes cortes definem a política operativa
do sistema hidrotérmico, representando o valor futuro da água em função
do estado do sistema.

.. GENERATED FROM PYTHON SOURCE LINES 13-23

.. code-block:: Python


    import numpy as np
    import pandas as pd
    import plotly.express as px
    import plotly.io as pio

    from inewave.newave import Cortes

    pio.templates.default = "ggplot2"








.. GENERATED FROM PYTHON SOURCE LINES 24-31

**Leitura dos cortes de Benders**

IMPORTANTE: A leitura dos cortes requer configuração específica baseada nas
dimensões do caso de estudo. Estes parâmetros devem corresponder exatamente
às configurações utilizadas na execução do NEWAVE:
IMPORTANTE: Foi gerado um arquivo cortes.dat reduzido utlizando o próprio módulo `inewave`
para fins de demonstração com apenas 1 corte. Em um caso real, utilize o arquivo gerado pelo NEWAVE.

.. GENERATED FROM PYTHON SOURCE LINES 31-62

.. code-block:: Python


    tamanho_registro = 17568
    indice_ultimo_corte = 1
    numero_total_cortes = 1
    codigos_rees = [1, 6, 7, 5, 10, 12, 2, 11, 3, 4, 8, 9]
    codigos_uhes = list(range(154))
    codigos_submercados = [1, 2, 3, 4] 
    ordem_maxima_parp = 12 
    lag_maximo_gnl = 2 

    print("Configuração da leitura dos cortes:")
    print(f"- Tamanho do registro: {tamanho_registro} bytes")
    print(f"- Último corte válido: {indice_ultimo_corte}")
    print(f"- Total de cortes: {numero_total_cortes}")
    print(f"- REEs: {codigos_rees}")
    print(f"- Submercados: {codigos_submercados}")

    # Leitura do arquivo cortes.dat
    arq_cortes = Cortes.read(
        "./newave/cortes.dat",
        tamanho_registro=tamanho_registro,
        indice_ultimo_corte=indice_ultimo_corte,
        numero_total_cortes=numero_total_cortes,
        codigos_rees=codigos_rees,
        codigos_uhes=codigos_uhes,
        codigos_submercados=codigos_submercados,
        ordem_maxima_parp=ordem_maxima_parp,
        lag_maximo_gnl=lag_maximo_gnl,
    )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Configuração da leitura dos cortes:
    - Tamanho do registro: 17568 bytes
    - Último corte válido: 1
    - Total de cortes: 1
    - REEs: [1, 6, 7, 5, 10, 12, 2, 11, 3, 4, 8, 9]
    - Submercados: [1, 2, 3, 4]




.. GENERATED FROM PYTHON SOURCE LINES 63-66

**Estrutura dos cortes de Benders**

Analisando a estrutura e conteúdo dos cortes:

.. GENERATED FROM PYTHON SOURCE LINES 66-75

.. code-block:: Python


    cortes = arq_cortes.cortes
    print(f"Total de cortes válidos: {len(cortes)}")
    print(f"Colunas disponíveis: {len(cortes.columns)}")

    print("\nPrimeiros registros:")
    print(cortes.head())






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Total de cortes válidos: 1
    Colunas disponíveis: 185

    Primeiros registros:
       indice_corte  ...  pi_gnl_sbm4_pat3_lag2
    0             1  ...                 40.611

    [1 rows x 185 columns]




.. GENERATED FROM PYTHON SOURCE LINES 76-79

**Análise dos coeficientes dos cortes**

Examinando os coeficientes que definem o valor da água:

.. GENERATED FROM PYTHON SOURCE LINES 79-133

.. code-block:: Python


    print("Análise dos coeficientes dos cortes:")

    # Identificando colunas de coeficientes (começam com "pi_")
    colunas_pi = [col for col in cortes.columns if col.startswith("pi_")]
    print(f"Número de coeficientes por corte: {len(colunas_pi)}")

    if len(colunas_pi) > 0:
        # Estatísticas dos coeficientes
        coeficientes_stats = cortes[colunas_pi].describe()
        print("\nEstatísticas dos coeficientes:")
        print(f"- Valor médio: {coeficientes_stats.loc['mean'].mean():.6f}")
        print(f"- Mínimo global: {coeficientes_stats.loc['min'].min():.6f}")
        print(f"- Máximo global: {coeficientes_stats.loc['max'].max():.6f}")

        # Analisando coeficientes de EARM (valor da água armazenada)
        colunas_earm = [col for col in colunas_pi if "earm" in col.lower()]
        if len(colunas_earm) > 0:
            print(
                f"\nAnálise dos coeficientes de EARM ({len(colunas_earm)} REEs):"
            )

            for col in colunas_earm[:5]:  # Primeiros 5 para não sobrecarregar
                ree_num = col.split("_")[-1] if "_" in col else "N/A"
                valores = cortes[col]
                print(f"- {col} (REE {ree_num}):")
                print(
                    f"  Média: {valores.mean():.4f}"
                )
                print(f"  Min: {valores.min():.4f}, Max: {valores.max():.4f}")

        # Analisando coeficientes de ENA (valor da energia afluente)
        colunas_ena = [col for col in colunas_pi if "ena" in col.lower()]
        if len(colunas_ena) > 0:
            print(
                f"\nAnálise dos coeficientes de ENA ({len(colunas_ena)} termos):"
            )

            # Agrupando por lag
            ena_por_lag = {}
            for col in colunas_ena:
                if "lag" in col:
                    lag = col.split("lag")[-1]
                    if lag not in ena_por_lag:
                        ena_por_lag[lag] = []
                    ena_por_lag[lag].append(col)

            for lag, cols in list(ena_por_lag.items())[:3]:  # Primeiros 3 lags
                valores_lag = cortes[cols].mean(
                    axis=1
                )  # Média entre REEs para cada corte
                print(
                    f"- Lag {lag}: Média: {valores_lag.mean():.6f}"
                )




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Análise dos coeficientes dos cortes:
    Número de coeficientes por corte: 180

    Estatísticas dos coeficientes:
    - Valor médio: 276.059043
    - Mínimo global: -174.659130
    - Máximo global: 6772.083260

    Análise dos coeficientes de EARM (12 REEs):
    - pi_earm_ree1 (REE ree1):
      Média: -1.2185
      Min: -1.2185, Max: -1.2185
    - pi_earm_ree6 (REE ree6):
      Média: -2.5457
      Min: -2.5457, Max: -2.5457
    - pi_earm_ree7 (REE ree7):
      Média: -1.2185
      Min: -1.2185, Max: -1.2185
    - pi_earm_ree5 (REE ree5):
      Média: -2.5420
      Min: -2.5420, Max: -2.5420
    - pi_earm_ree10 (REE ree10):
      Média: -1.1970
      Min: -1.1970, Max: -1.1970

    Análise dos coeficientes de ENA (144 termos):
    - Lag 1: Média: 483.088869
    - Lag 2: Média: 537.230787
    - Lag 3: Média: 544.047427





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.176 seconds)


.. _sphx_glr_download_examples_plot_cortes.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_cortes.ipynb <plot_cortes.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_cortes.py <plot_cortes.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_cortes.zip <plot_cortes.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
